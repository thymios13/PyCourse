---
title: Object Orientation
---

##More on Objects

###Object Based Programming Recap

We saw last lesson how to 

* create our own classes
* store data with member variables
* add functionality with member functions
* initialise objects with constructors

###Class design

The concepts we have introduced are common between different object oriented languages.
Thus, when we design our program using these concepts, we can think at an architectural level,
independent of language syntax.

{{pyfrag('06','design','pyclass')}}

``` cpp
class Particle {
    std::vector<double> position;
    std::vector<double> velocity;
    Particle(std::vector<double> position, std::vector<double> velocity);
    void move(double delta_t);
}
```

``` fortran
type particle
    real :: position
    real :: velocity
  contains
    procedure :: init
    procedure :: move
end type particle
```

###UML

UML is a conventional diagrammatic notation used to describe "class structures" and other higher level
aspects of software design.

Computer scientists get worked up about formal correctness of UML diagrams and learning the conventions precisely.
Working programmers can still benefit from using UML to describe their designs.

###UML for objects

UML represents class members and methods like this:

![Basic class UML](session06/figures/basic.png)

(The above diagram is generated by the following:

``` raw
http://yuml.me/diagram/boring/class/[Particle|position;velocity|move()]
```

using the [YUML](http://yuml.me/) online UML drawing tool.

##Information Hiding

Sometimes, our design for a program would be broken if users start messing around with variables we don't want them to change.

Robust class design requires consideration of which subroutines are intended for users to use, and which are internal.
Languages provide features to implement this: access control. 

In python, we use leading underscores to control whether member variables and methods can be accessed from outside the class.

{{pyfrag('06','design','hiding')}}

###Property accessors

Python provides a mechanism to make functions appear to be variables. This can be used if you want to
change the way a class is implemented without changing the interface:

{{pyfrag('06','design','accessors1')}}

becomes:

{{pyfrag('06','design','accessors2')}}

Note that the code behaves the same way to the outside user.
The implementation detail is hidden by private variables.
In languages without this feature, such as C++, it is best to always
make data private, and always
access data through functions:

{{pyfrag('06','design','accessors3')}}

But in Python this is unnecessary.

###Class Members

*Class*, or *static* members, belong to the class as a whole, and are shared between instances.

{{pyfrag('06','design','classmethod')}}

### Object-based vs Object-Oriented

So far we have seen only object-based programming, not object-oriented programming.

Using Objects doesn't mean your code is object-oriented.

To understand object-oriented programming, we need to introduce **polymorphism** and **inheritance**.

##Inheritance

* Inheritance allows related classes to share code
* Inheritance allows a program to reflect the *ontology* of kinds of thing in a program.

###Ontology and inheritance

* A bird is a kind of animal
* An eagle is a kind of bird
* A starling is also a kind of bird

* All animals can be born and die
* Only birds can fly (Ish.)
* Only eagles hunt
* Only starlings flock

###Inheritance in python

{{pyfrag('06','design','inheritance')}}

###Inheritance terminology

* A *derived class* _derives_ from a *base class*
* A *subclass* _inherits_ from a *superclass*

(These are different terms for the same thing.)

* Eagle is a subclass of the Animal superclass.
* Animal is the base class of the Eagle derived class

###Inheritance and constructors

{{pyfrag('06','design','super')}}

###Inheritance UML diagrams

UML shows inheritance with an open triangular arrow pointing from subclass to superclass.

![Bird inheritance diagram](session06/figures/inheritance.png)

###Aggregation vs Inheritance

If one object *has* or *owns* one or more objects, this is *not* inheritance.

For example, in my solution to the Boids task from last week, the overal Model owned several Boids,
and each Boid owned two 2-vectors, one for position and one for velocity.

###Aggregation in UML

The Boids situation can be represented thus:

![Boid aggregation diagram](session06/figures/aggregation.png)

The open diamond indicates **Aggregation**, the closed diamond **composition**.
(A given boid might belong to multiple models, a given position vector is forever part of the corresponding Boid.)

The asterisk represents cardinality, a model may contain multiple Boids.

###Refactoring to inheritance

Smell: Repeated code between two classes which are both ontologically subtypes of something

Before:

{{pyfrag('06','design','inheritance_factor1')}}

After:

{{pyfrag('06','design','inheritance_factor2')}}

##Polymorphism

###Polymorphism

{{pyfrag('06','design','polymorphism')}}

This will print "Bark Bark Miaow Oink Moo Miaow"

If two classes support the same method, but it does different things for the two classes, 
then if an object is of an unknown class, calling the method will invoke the version for
whatever class the instance is an instance of.

###Polymorphism and Inheritance

Often, polymorphism uses multiple derived classes with a common base class.
However, duck typing in Python means that all that is required is that the 
types support a common **Concept** (Such as iterable, or container, or, in this case, the
Noisy concept.)

A common base class is used where there is a likely **default** that you want several
of the derived classes to have.

{{pyfrag('06','design','base')}}

###Undefined Functions and Polymorphism

In the above example, we put in a dummy noise for Animals that don't know what type they are.

Instead, we can explicitly deliberately leave this undefined, and we get a crash if we access an undefined method.

{{pyfrag('06','design','undefined')}}

###Refactoring to Polymorphism

Smell: a function uses a big set of `if` statements or a `case` statement to decide what to do:

Before:

{{pyfrag('06','design','case')}}

which is better replaced by the code above.

###Interfaces and concepts

In C++, it is common to define classes which declare dummy methods, called "virtual" methods, which specify
the methods which derived classes must implement. Classes which define these methods, which cannot be instantiated
into actual objects, are called "abstract base" classes or "interfaces".

Python's Duck Typing approach means explicitly declaring these is unnesssary: any class concept which implements
appropriately named methods will do. These as user-defined **concepts**, just as "iterable" or "container" are 
built-in Python concepts. A class is said to "implement and interface" or "satisfy a concept".

###Interfaces in UML

Interfaces implementation in UML is indicated thus:

![Interfaces in UML](session06/figures/interface.png)

###Further UML

UML is a much larger diagram language than the aspects we've shown here.

* Message sequence charts show signals passing back and forth between objects ([Web Sequence Diagrams](https://www.websequencediagrams.com/))

* Entity Relationship Diagrams can be used to show more general relationships between things in a system



